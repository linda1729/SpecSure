我是一个软件工程课程的大作业学生，我们小组选的题目是：**“海岸带高光谱数据分类系统”**。

### 1. 项目背景 & 功能要求（老师给的）

- 目标：做一个**原型系统**，对海岸带高光谱遥感数据（HSI）进行地物分类。
- 典型地物：滩涂、盐沼、盐田、水体、港口、人工建筑等。
- 数据特点：波段多（几百个）、噪声多、空间分辨率有限、标注成本高。
- 系统需要完成的功能：
  1. **数据导入 + 预处理**
     - 数据读取
     - 降噪
     - 波段选择
     - 标准化等
  2. **分类模块**
     - 至少支持 **两种模型** 的分类结果对比（例如 Model A / Model B）
  3. **分类结果可视化**
     - 伪彩色图（RGB 合成）
     - 分类结果图
     - 与标注对比
  4. **性能评估**
     - 准确率（Accuracy）
     - Kappa 系数
     - 混淆矩阵等指标

------

### 2. 我个人负责的部分

我在小组里的主要角色是：**后端开发**（顺带做一个过渡用的简易前端）。

当前计划是分阶段做：

1. **第一阶段：用模拟数据把后端流程打通**
   - 先不用真实高光谱数据，自己在后端生成或读取一些 **模拟 HSI 数据**（形状类似 `H × W × C`）。
   - 模型部分先用“假模型”或者简单的传统方法（比如 sklearn），**重点是先把接口、数据流和可视化结果跑通**。
   - 后续再把“模型预测”这一块替换成同学提供的真实模型 API。
2. **第二阶段：接入同学的模型训练 / 推理 API**
   - 和负责模型训练的同学约定一个稳定的后端接口（例如 Python 函数或 HTTP API）。
   - 保持前端调用后端的 API **不变**，只是后端内部从“模拟模型”切换到“真实模型”。
3. **第三阶段：和前端同学对接正式界面**
   - 我现在只会写一个简单的前端（比如几个表单 + 图像查看），主要用来调试后端。
   - 等后端 API 相对稳定后，再交给前端同学做漂亮的可视化界面和交互。

------

### 3. 我希望做

1. **后端整体结构设计**
   - 推荐一个合适的技术栈（比如：Python + FastAPI / Flask，或者其它你认为更适合的）。
   - 规划项目目录结构，例如：
     - `backend/app/main.py`（入口）
     - `backend/app/api/`（路由）
     - `backend/app/core/`（核心处理：预处理、模型、评估）
     - `backend/app/models/`（数据结构 / Pydantic 模型等）
     - `backend/data/`（存放模拟数据、结果）
2. **详细的 API 设计**
    希望能有一套比较清晰、前后端都容易理解的 REST API，大致需要：
   - **数据管理相关**
     - 上传 / 载入高光谱数据（目前可以是 `.npy` 模拟数据）
     - 返回数据的维度（H、W、bands）和一些元信息
     - 返回一张 RGB 伪彩色预览图（比如前端通过 URL 加载）
   - **预处理相关**
     - 接收预处理参数（是否降噪、降噪方式、波段选择方法、标准化方式等），返回一个“预处理后的数据 ID”或结果描述。
   - **模型 & 分类相关**
     - 一个接口可以传入：
       - 使用哪个数据集 / 预处理结果
       - 模型 A 的参数
       - 模型 B 的参数
     - 然后返回：
       - 每个模型的分类结果（例如分类图的 URL / 文件路径）
       - 后续评估用到的预测结果 ID
   - **可视化 & 像元查询**
     - 获取原始/预测结果图（图片 URL）
     - 传入某个像元坐标（row, col），返回：
       - 原始光谱曲线
       - 真实类别
       - 模型 A / B 的预测类别
   - **评估相关**
     - 传入真实标注 + 某个模型的预测结果
     - 返回：准确率、Kappa、混淆矩阵、每类精度等。
3. **数据格式 & 前端需要传的参数**
   - 帮我规范每个接口的 **请求 / 响应 JSON 格式**，比如：
     - `POST /api/preprocess/run` 时前端传什么字段？
     - `POST /api/train-and-predict` 时如何描述两个模型及其参数？
     - `POST /api/evaluate` 时需要哪些 ID？
   - 这些格式会直接给我们前端同学用，所以希望尽可能清晰、有注释。
4. **第一版可运行样例**
   - 用 **模拟数据** 和一个简单模型（比如 `sklearn.SVC` 或 `RandomForest`）
   - 搭出一条最简流程：
     1. 模拟载入一幅 HSI 数据
     2. 做一次简单预处理
     3. 跑一个模型做分类
     4. 生成一张分类结果图（伪彩色）
     5. 算一个简单的 Accuracy 和混淆矩阵
   - 这样我就可以在这个基础上逐步替换成真正的数据和模型。

**项目的后端，核心就是 4 类能力：**

1. **数据管理**：接收/保存高光谱数据，返回维度、波长等元数据 + 预览图 + 光谱曲线
2. **预处理流水线**：根据前端发来的参数，对数据做“降噪 + 波段选择 + 标准化”，并生成一个“预处理版本”
3. **分类 / 模型接口**：把“预处理后的数据 + 标注”送给模型训练，同一套接口支持 A/B 两种模型，并输出分类结果图
4. **评估接口**：根据“预测结果 + 真实标注”，算出 Accuracy、Kappa、混淆矩阵等，并返回给前端展示

------

## 一、整体架构（我负责的后端定位）

- **前端**：简单版先用任意框架（Vue/React 都行），只要能：
  - 上传文件
  - 填一些参数（滑块/下拉框）
  - 请求图片 / JSON 并展示
- **后端（你负责）**：
  - 语言：Python
  - 框架：**FastAPI**（写 REST API 很爽，自动文档 + Pydantic 校验）
  - 科学计算：`numpy + scipy + scikit-learn`，后期如果接深度学习再接 `torch` 或直接调你同学的 API
  - 文件存储：先用 **本地文件夹** `data/`，记录到一个小的 `sqlite` 或简单 `datasets.json`
- **数据文件形式**（方便你 mock）：
  - 真实情况：`.hdr/.dat`、`.mat`、`.tif` 等高光谱数据
  - 开发前期：可以先用 `.npy` / `.npz`，形状约定为 `H x W x C`（行、列、波段）

------

## 二、核心数据结构（后端内部）

先定清楚你在后端要“存什么”。

### 1. Dataset（原始或预处理后的数据）

```jsonc
{
  "id": "ds_001",
  "name": "coastline_hsi_data",
  "path": "data/raw/ds_001.npy",
  "rows": 512,
  "cols": 256,
  "bands": 200,
  "wavelengths": [400.0, 405.0, ...],   // nm，可选
  "meta": {
    "sensor": "AVIRIS",
    "location": "Qingdao coast",
    "wavelength_range": [400.0, 2500.0]
  }
}
```

### 2. PreprocessPipeline（一次预处理配置）

```jsonc
{
  "id": "pp_001",
  "dataset_id": "ds_001",
  "noise_reduction": {
    "enabled": true,
    "method": "gaussian",     // or "median"
    "kernel_size": 3
  },
  "band_selection": {
    "enabled": true,
    "method": "manual",       // "manual" | "pca"
    "manual_ranges": [[10, 150]],
    "n_components": 30
  },
  "normalization": {
    "enabled": true,
    "method": "zscore"        // "minmax"
  },
  "output_dataset_id": "ds_001_pp1"
}
```

### 3. LabelMask（真实标注 / 训练样本）

```jsonc
{
  "id": "lb_001",
  "dataset_id": "ds_001",
  "path": "data/labels/lb_001.npy",   // 2D array (H x W), int 类别编号
  "classes": [
    {"id": 1, "name": "Water"},
    {"id": 2, "name": "SaltMarsh"},
    {"id": 3, "name": "SaltPan"},
    {"id": 4, "name": "Mudflat"},
    {"id": 5, "name": "Buildings"}
  ]
}
```

### 4. ModelConfig / ModelRun（一次训练任务）

```jsonc
{
  "id": "modelA_001",
  "type": "svm",                 // "svm" | "rf" | "cnn3d" 等
  "dataset_id": "ds_001_pp1",    // 通常用预处理后的
  "label_id": "lb_001",
  "train_ratio": 0.7,
  "random_seed": 42,
  "params": {
    "C": 1.0,
    "gamma": 0.1,
    "kernel": "rbf"
  },
  "status": "finished",          // "pending" | "running" | "finished" | "failed"
  "model_path": "backend/saved_models/modelA_001.joblib",
  "prediction_result_id": "pred_001"
}
```

### 5. PredictionResult（分类结果）

```jsonc
{
  "id": "pred_001",
  "model_id": "modelA_001",
  "dataset_id": "ds_001_pp1",
  "pred_mask_path": "data/predictions/pred_001.npy",  // H x W
  "preview_image_path": "data/previews/pred_001.png"
}
```

### 6. EvaluationResult（评估指标）

```jsonc
{
  "id": "eval_001",
  "prediction_id": "pred_001",
  "label_id": "lb_001",
  "overall_accuracy": 0.92,
  "kappa": 0.88,
  "per_class": [
    {
      "class_id": 1,
      "class_name": "Water",
      "producer_accuracy": 0.97,
      "user_accuracy": 0.95
    }
  ],
  "confusion_matrix": {
    "labels": [1, 2, 3, 4, 5],
    "matrix": [
      [1034,  10,   2,   1,   0],
      [  15, 900,  30,   5,   0],
      ...
    ]
  }
}
```

------

## 三、API 设计总览（按模块）

### 模块 1：数据管理 Data Management

#### 1. 上传数据

```
POST /api/datasets/upload
```

- **请求（multipart/form-data）**
  - `file`: 高光谱数据文件（你前期也可以只用 `.npy`）
  - `name`（可选）
- **响应**

```json
{
  "dataset": {
    "id": "ds_001",
    "name": "coastline_hsi_data",
    "rows": 512,
    "cols": 256,
    "bands": 200,
    "wavelength_range": [400.0, 2500.0]
  }
}
```

#### 2. 获取数据列表

```
GET /api/datasets
[
  {"id": "ds_001", "name": "coastline_hsi_data", "rows": 512, "cols": 256, "bands": 200},
  ...
]
```

#### 3. 获取单个数据元信息

```
GET /api/datasets/{dataset_id}/metadata
```

返回 Dataset 结构，用于前端在“数据导入页面”显示维度、波段等。

#### 4. RGB 预览图

```
GET /api/datasets/{dataset_id}/preview-rgb?r=30&g=20&b=10&downsample=4
```

- 后端：从 HSI 按三个 band 抽出，归一化到 0–255，做下采样，生成 PNG
- 响应：可以是图片 URL，也可以直接二进制流（看你怎么方便）

简单一点，用 JSON 返回一个静态文件 URL：

```json
{
  "image_url": "/static/previews/ds_001_rgb_r30_g20_b10.png"
}
```

#### 5. 光谱曲线

```
GET /api/datasets/{dataset_id}/spectrum?row=120&col=45&stage=raw
```

- `stage`: `"raw"` or `"preprocessed"`（方便后期对比）

```json
{
  "row": 120,
  "col": 45,
  "wavelengths": [400.0, 405.0, ...],
  "reflectance": [0.12, 0.15, ...]
}
```

------

### 模块 2：预处理 Preprocessing

前端页面对应“Data Preprocessing / 预处理模块”。

#### 1. 执行一次预处理

```
POST /api/preprocess/run
```

- **请求体**

```json
{
  "dataset_id": "ds_001",
  "noise_reduction": {
    "enabled": true,
    "method": "gaussian",
    "kernel_size": 3
  },
  "band_selection": {
    "enabled": true,
    "method": "manual",       // "manual" | "pca"
    "manual_ranges": [[10, 150]],
    "n_components": 30
  },
  "normalization": {
    "enabled": true,
    "method": "minmax"
  }
}
```

- **响应**

```json
{
  "pipeline": {
    "id": "pp_001",
    "dataset_id": "ds_001",
    "output_dataset_id": "ds_001_pp1"
  },
  "output_dataset": {
    "id": "ds_001_pp1",
    "rows": 512,
    "cols": 256,
    "bands": 180
  }
}
```

前端在“预处理页面”点 `Apply Preprocessing` 按钮时，就调用这一个接口。

------

### 模块 3：标注 / 样本 Label Management

你可以做一个简单版即可：

#### 1. 上传标注图（整幅 mask）

```
POST /api/labels/upload
```

- multipart：`file`（H x W 的整型 mask，比如 `.npy` 或 `.tif`），`dataset_id`
- 请求 JSON 可带 `classes`（可选）
- **响应**

```json
{
  "label": {
    "id": "lb_001",
    "dataset_id": "ds_001",
    "classes": [
      {"id": 1, "name": "Water"},
      {"id": 2, "name": "Salt Marsh"},
      ...
    ],
    "stats": [
      {"class_id": 1, "count": 320},
      {"class_id": 2, "count": 280}
    ]
  }
}
```

以后要做“交互式标注”（框选一块区域追加样本），可以再加类似：

```
POST /api/labels/{label_id}/add-rect
```

------

### 模块 4：模型训练与分类 Model Training & Prediction

对应文档中的“模型 A/B 对比、训练参数设置、进度条”等。

#### 1. 启动训练 + 全图预测（一次性走完）

```
POST /api/train-and-predict
```

- **请求体示例**

```json
{
  "dataset_id": "ds_001_pp1",
  "label_id": "lb_001",
  "models": [
    {
      "name": "ModelA",
      "type": "svm",
      "enabled": true,
      "train_ratio": 0.7,
      "params": {
        "kernel": "rbf",
        "C": 1.0,
        "gamma": 0.1
      }
    },
    {
      "name": "ModelB",
      "type": "cnn3d",
      "enabled": true,
      "train_ratio": 0.7,
      "params": {
        "patch_size": 7,
        "epochs": 50,
        "batch_size": 32
      }
    }
  ],
  "random_seed": 42
}
```

- **响应体（简单同步版）**

```json
{
  "runs": [
    {
      "model_run": {
        "id": "modelA_001",
        "type": "svm",
        "status": "finished"
      },
      "prediction": {
        "id": "pred_001",
        "preview_image_url": "/static/pred/pred_001.png"
      }
    },
    {
      "model_run": {
        "id": "modelB_001",
        "type": "cnn3d",
        "status": "finished"
      },
      "prediction": {
        "id": "pred_002",
        "preview_image_url": "/static/pred/pred_002.png"
      }
    }
  ]
}
```

> **前期 mock 建议**：
>
> - ModelA 模拟用 `sklearn.SVC` 真的训一下（速度快）；
> - ModelB 先写一个“假 CNN”：随机初始化，然后用简单的 `RandomForest` 代替，但在 API 上仍叫 `cnn3d`，后面和同学对接时只要改内部实现，不改接口。

如果你想做“异步 + 进度条”，可以改成：

- `POST /api/train-and-predict` 返回一个 `task_id`
- 前端定时 `GET /api/tasks/{task_id}/status` 拉进度

现在课程实验一般不用搞这么复杂，你先做同步版即可。

------

### 模块 5：结果可视化 Visualization

前端在“可视化”页面需要显示：

- 原始假彩色图
- 模型 A 分类图
- 模型 B 分类图
- 鼠标移动显示某像元的“真实类别 + A 预测 + B 预测”

你可以提供几个接口：

#### 1. 获取特定结果的伪彩色图

```
GET /api/predictions/{pred_id}/image
```

→ 返回 PNG/URL

#### 2. 像元信息查询

```
GET /api/pixel-info?dataset_id=ds_001_pp1&label_id=lb_001&predA_id=pred_001&predB_id=pred_002&row=120&col=45
```

- **响应**

```json
{
  "row": 120,
  "col": 45,
  "ground_truth": {
    "class_id": 3,
    "class_name": "Salt Pan"
  },
  "modelA": {
    "class_id": 3,
    "class_name": "Salt Pan"
  },
  "modelB": {
    "class_id": 5,
    "class_name": "Buildings"
  }
}
```

------

### 模块 6：性能评估 Evaluation

对应“OA、Kappa、混淆矩阵、每类精度”等。

#### 1. 计算评估

```
POST /api/evaluate
```

- **请求**

```json
{
  "prediction_id": "pred_001",
  "label_id": "lb_001"
}
```

- **响应**

直接返回 EvaluationResult 结构，前端拿来画热力图、OA、Kappa 圆圈卡片等。

------

## 四、前端页面需要传的关键参数

你以后可以直接把这段给做前端的同学看。

1. **数据导入页**
   - `POST /api/datasets/upload` 上传文件
   - `GET /api/datasets/{id}/metadata` 显示维度、波长范围
   - `GET /api/datasets/{id}/preview-rgb?r=&g=&b=` 生成假彩色图
   - `GET /api/datasets/{id}/spectrum?row=&col=&stage=raw` 鼠标点图上的像素
2. **预处理页**
   - 前端需要维护一份配置对象（对应上文 `noise_reduction`、`band_selection`、`normalization`）
   - 点击“Apply Preprocessing”：
     - `POST /api/preprocess/run` 传这份配置
     - 成功后拿到 `output_dataset_id`，后面训练/可视化都用这个 id
3. **模型训练页**
   - 收集页面上的：
     - 模型开关（ModelA ON/OFF、ModelB ON/OFF）
     - 类型选择（SVM / RF / CNN）
     - 参数（C、gamma、epochs、batch_size…）
     - 训练集比例 `train_ratio`
     - 随机种子 `random_seed`
   - 点击“Start Training”：
     - `POST /api/train-and-predict` 携带上述参数
     - 返回每个模型的 `model_run_id` 和 `prediction_id`，存到前端状态，用于后续页面
4. **结果与可视化页**
   - 调用：
     - `GET /api/datasets/{original_id}/preview-rgb` -> 原始假彩色图
     - `GET /api/predictions/{pred_id}/image` -> 模型分类图
     - 鼠标移动时：`GET /api/pixel-info?...` -> 像元信息弹窗
5. **性能评估页**
   - 页面选择某个模型（SVM / CNN）
   - 请求：`POST /api/evaluate`（或 `GET /api/evaluations/{id}`）
   - 用返回的 OA/Kappa/混淆矩阵/每类 PA、UA 画出图表和表格。

------

## 五、分阶段开发建议（配合“先模拟数据再接模型”的计划）

你现在是后端主程，建议按照难度从低到高分三步：

### 阶段 1：完全 mock 版（1–2 天内就能跑通 demo）

- 数据：用 `numpy.random.rand(H, W, C)` 造一幅假 HSI，再存到 `.npy`
- 预处理：函数里其实只做一些简单运算（比如对所有波段除以最大值），只要接口是对的
- 分类：
  - ModelA：随便用 `sklearn.SVC` 或 `RandomForest` 训一下
  - ModelB：先 copy ModelA 的结果，或者用另一套随机种子——重点是**接口一致，能出两张分类图**
- 评估：用 `sklearn.metrics` 算 confusion matrix、accuracy、kappa

> 目标：**从上传数据 → 预处理 → 训练两种模型 → 看两张伪彩色分类图 + 一个指标面板** 整条链路打通。

### 阶段 2：换成真实 HSI 数据 & 稍微认真一点的预处理

- 写 `load_hsi.py` 支持 `.mat` / `.hdr+.dat` / `.tif` 之一
- 在 `spectral_tools.py` 实现真·平滑滤波、噪声波段剔除、波段选择（手工 + PCA）
- 让预处理参数真的影响到分类效果（波段减少、标准化方式不同）

### 阶段 3：与同学的深度模型对接

- 约定一个“内部 Python 接口”即可，例如：

  ```python
  def train_and_predict_cnn3d(hsi_cube: np.ndarray,
                              labels: np.ndarray,
                              train_ratio: float,
                              patch_size: int,
                              epochs: int,
                              batch_size: int,
                              random_seed: int) -> np.ndarray:
      """返回 H x W 的预测 mask"""
  ```

- 你那边 `ModelB` 的实现直接调用这个函数（或 HTTP API），前端 / API 完全不用改。

